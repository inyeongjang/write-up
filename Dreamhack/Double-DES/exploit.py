from pwn import *
from Crypto.Cipher import DES

# prob.py 로컬 실행 
io = process(["python3", "prob.py"])

# 원격 서버 접속
io = remote("host8.dreamhack.games", 14965)

# 서버가 출력하는 힌트 부분까지 읽기 
io.recvuntil(b":> ")

# hex 문자열 -> bytes로 변환 
hint = bytes.fromhex(io.recvline().decode())

conflict = dict()

for i in range(65536):
    b = i.to_bytes(2, "big")
    
    # key1 = b"Dream_" + 2바이트 
    cipher = DES.new(b"Dream_" + b, DES.MODE_ECB)
    
    # key1로 암호화 
    enc = cipher.encrypt(b"DreamHack_blocks")
    
    # conflict[암호문] = key1 
    conflict[enc] = b"Dream_" + b

for i in range(65536):
    b = i.to_bytes(2, "big")
    
    # key2 = (2 바이트) + b"Hacker"
    cipher = DES.new(b + b"Hacker", DES.MODE_ECB)
    
    # key2로 복호화 
    dec = cipher.decrypt(hint)

    if dec in conflict:
        key1 = conflict[dec]
        key2 = b + b"Hacker"
        break

# 찾은 key1, key2로 DES 객체 다시 생성 
cipher1 = DES.new(key1, DES.MODE_ECB)
cipher2 = DES.new(key2, DES.MODE_ECB)

# 서버와 동일한 encrypt 함수 정의 
encrypt = lambda x: cipher2.encrypt(cipher1.encrypt(x))

# 찾은 key 조합이 실제 서버 힌트와 일치하는지 검증 
assert encrypt(b"DreamHack_blocks") == hint

# 'give me the flag'을 암호화한 hex 값을 서버로 전송 
io.sendlineafter(b'> ', encrypt(b"give_me_the_flag").hex().encode())

# 서버가 flag를 Python bytes literal 형태로 보내므로 eval로 변환
flag = eval(io.recvline())

io.close()

# flag 출력 
print(flag.decode())
